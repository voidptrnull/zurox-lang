{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Index","text":"<p>This is the homepage for the documentation concerning Zurox Programming Language. This serves as the information portal related to the language itself and tools related to it.</p> <p></p>"},{"location":"#brief-introduction-to-zurox","title":"Brief Introduction To Zurox","text":"<p>Zurox can be characterized from the following features: - Simple &amp; Minimal  - Supports many platforms  - System's Programming &amp; Low level language.</p> <p>Zurox intends to be as simple as possible while allowing the user to still empowering users to create what they want to create.  Some of them might be controversial or may not be that difficult to grasp but I still went ahead and got rid of them ! </p>"},{"location":"#structure-of-the-documentation","title":"Structure of the Documentation","text":"<ul> <li><code>compiler</code> - This deals with the implementation of the compiler for the language.</li> <li><code>interpreter</code>(TO BE ADDED) - This deals with the the implementation for the bitcode interpreter of the language.</li> <li><code>zxpm</code> [Zurox Package Manager] (TO BE ADDED) - This deals with documentation for the package manager tool.</li> </ul>"},{"location":"#divisions","title":"Divisions","text":"<p>The structures are further divided into subdivisions, namely <code>internal</code> for the implementation itself, and <code>external</code> for usage.</p>"},{"location":"changes/","title":"Changes in Zurox","text":"<p>Here are some of the things that were changed/removed.</p> <ul> <li> <p>Pointers and dereferncing are done by using keywords <code>ref</code> and <code>deref</code> respectively. This intends to get rid of confusing pointer arithmetic like this:     <pre><code>char*(*(*x[][8]));\n</code></pre></p> <p>which in turn would look like  <pre><code>char ref (deref (deref x[][8])) \n</code></pre></p> <p>Someone confirm this please</p> </li> <li> <p>Removal of while, for and do-while loops. While they could be benificial, since Zurox aims to be minimal, they were removed from Zurox. This is some sample code from C and Zurox, comparing them.     <pre><code>for (int i = 0;i &lt; 10;i++) {\n    // ... body\n}\n\nint i = 0;\nwhile (i &lt; 10) {\n    // ... body\n    i++;\n}\n\ni = 1; // Reset\ndo {\n    // ... body\n    ++i;\n} while (i &lt; 10);\n</code></pre></p> <pre><code>i32 i = 0;\nloop {\n    // ... body\n    if (i == 10) {\n        break;\n    }\n    i += 1;\n}\n</code></pre> </li> </ul>"},{"location":"compiler/compiler/","title":"About Compiler","text":"<p>The two folders <code>internal</code> and <code>external</code> contains the documentation for the compiler.</p> <p>The <code>internal</code> folder is concerned with the actual implementation.</p> <p>The <code>external</code> folder deals with usage and integration.</p>"},{"location":"compiler/compiler/#usage","title":"Usage","text":"<p>Check <code>zuroxc --help</code> for usage info and <code>internal</code> for more details.</p>"},{"location":"compiler/compiler/#structure","title":"Structure","text":"<p>The compiler is implemented in this manner.</p> <ul> <li> <p>Lexer (Lexical Analysis)</p> </li> <li> <p>Parser (Syntax Analysis)</p> </li> <li> <p>Analyzer (Semantic Analysis)</p> </li> <li> <p>Code Generator (LLVM IR Generator)</p> </li> </ul>"},{"location":"compiler/internal/a_tokens/","title":"1. Tokens Documentation","text":"<p>Each token is treated as single word.</p> <p>To give a vague idea, refer to the below example.</p>"},{"location":"compiler/internal/a_tokens/#token-example","title":"Token Example","text":"<pre><code>int main() {\n    int x = 42;\n    return x;\n}\n</code></pre> <p>Here the tokens will be the following: - <code>int</code> - <code>main</code> - <code>(</code> - <code>)</code> - <code>{</code> - <code>int</code> - <code>x</code> - <code>=</code> - <code>42</code> - <code>;</code> - <code>return</code> - <code>x</code> - <code>}</code></p> <p>Notice how whitespace is ignored. Also notice how <code>(</code> and <code>)</code> are present together but treated differently. But you may wonder now, how do we use this ? Well before we get to that, we will sort of classify them.</p>"},{"location":"compiler/internal/a_tokens/#token-types","title":"Token Types","text":"<p>Here, the tokens can be roughly categorized into the following: - Keywords - Identifiers - Seperators - Operators - Literals - Custom Tokens like EOF, and ERR tokens.</p> <p>So take the above mentioned list of tokens for the C code, and you get: - Keywords like <code>return</code> - Seperators like <code>(</code> - Literals like <code>42</code> - Identifiers like <code>x</code>.</p> <p>Zurox has another category for the tokens, which are the datatypes like <code>int</code> in C-like languages or <code>i32</code> in Rust and also in Zurox.</p> <p>This is the enumeration which is actually used. Notice the presence of literals.</p> <pre><code>enum TokenType\n{\n    TK_DATATYPE,\n    TK_KEYWORD,\n    TK_SEPERATOR,\n    TK_OPERATOR,\n    TK_ID,\n\n    TKL_INT,\n    TKL_FLOAT,\n    TKL_CHAR,\n    TKL_STR,\n\n    TK_ERR,\n    __EOF,\n};\n</code></pre> <p>But just knowing the type won't do, we also need to know information like line and column number, and most importantly the actual lexeme like <code>int</code>, etc. To achieve that, we implement the following struct: <pre><code>struct Token\n{\n    TokenType type;\n    int_t line;\n    int_t col;\n    std::string lexeme;\n    Token(TokenType _type, int_t _line, int_t _col, const std::string &amp;_lexeme)\n        : type(_type), line(_line), col(_col), lexeme(_lexeme) {}\n    Token(TokenType _type, int_t _line, int_t _col, const char &amp;_lexeme)\n        : type(_type), line(_line), col(_col)\n    {\n        lexeme.push_back(_lexeme);\n    }\n};\n</code></pre></p> <p>Note: <code>int_t</code> is just <code>unsigned long int</code>.</p> <p>The constructors are used to create a new token, where the lexeme may be a single character as in case of seperators or a string.</p>"},{"location":"compiler/internal/b_lexer/","title":"2. Lexer Documentation","text":""},{"location":"compiler/internal/b_lexer/#overview","title":"Overview","text":"<p>The <code>Lexer</code> class provides a mechanism for lexical analysis of source files.</p>"},{"location":"compiler/internal/b_lexer/#process","title":"Process","text":"<p>The lexer first takes the file and then lexicographically processes the files character-by-character. It then transforms them in tokens with various data. Then it stores them into a vector. Upon reaching the end-of-file, it appends a custom <code>EOF</code> token to the vector and returns it to the caller.</p> <p>Helper functions like <code>advance</code>, <code>peek</code> and <code>current</code> are used to retrieve character information.</p> <p>The file and it's name is provided through the constructor.</p>"},{"location":"compiler/internal/b_lexer/#example-usage","title":"Example Usage","text":"<pre><code>#include &lt;lexer.hh&gt;\n#include &lt;iostream&gt;\n\nint main() {\n    // Example usage of Lexer\n    std::string fileContent = \"fn main() { ret 0; }\";\n    std::string fileName = \"example.zx\";\n    PrintGlobalState printState;\n\n    Lexer lexer(fileContent, fileName, printState);\n    auto tokens = lexer.lex();\n\n    // Print tokens\n    for (const auto&amp; token : tokens) {\n        std::cout &lt;&lt; \"Token: \" &lt;&lt; token.type &lt;&lt; \", Value: \" &lt;&lt; token.lexeme &lt;&lt; std::endl;\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"compiler/internal/b_lexer/#insight","title":"Insight","text":"<p>Here is the actual accessible part of the Lexer: <pre><code>#ifndef LEXER_HH\n#define LEXER_HH\n\n#include &lt;string&gt;\n#include &lt;vector&gt;\n#include &lt;token.hh&gt;\n#include &lt;print.hh&gt;\n#include &lt;llvm/ADT/StringRef.h&gt;\n\n/**\n * @brief Lexer class for lexical analysis of a source file.\n */\nclass Lexer\n{\npublic:\n    /**\n     * @brief Constructor for Lexer.\n     * @param file Content of the file to lex.\n     * @param file_name Name of the file being lexed.\n     * @param print PrintGlobalState object for printing.\n     */\n    Lexer(const std::string &amp;file, const std::string &amp;file_name, PrintGlobalState &amp;print);\n\n    /**\n     * @brief Lexical analysis of the file.\n     * @return Vector of tokens generated from the lexing process.\n     */\n    std::vector&lt;Token&gt; lex();\n\n    /**\n     * @brief Get the content of the file being lexed.\n     * @return Reference to the file content.\n     */\n    llvm::StringRef getFile();\n\nprivate:\n    size_t line, col;                ///&lt; Current line and column in the file.\n    std::vector&lt;Token&gt; tokens;       ///&lt; Tokens generated during lexing.\n    std::string file;                ///&lt; Content of the file to lex.\n    std::string file_name;           ///&lt; Name of the file being lexed.\n    PrintGlobalState &amp;print;         ///&lt; Reference to PrintGlobalState for printing.\n\n    /**\n     * @brief Get the current character in the file.\n     * @return Current character.\n     */\n    inline char current() const;\n\n    /**\n     * @brief Get the next character in the file.\n     * @return Next character.\n     */\n    inline char peek() const;\n\n    /**\n     * @brief Get the previous character in the file.\n     * @return Previous character.\n     */\n    inline char previous() const;\n\n    /**\n     * @brief Advance to the next character in the file.\n     */\n    inline void advance();\n\n    /**\n     * @brief Handle keywords, datatypes, or identifiers.\n     */\n    void keywordOrDatatypeOrIdentifier();\n\n    /**\n     * @brief Handle numbers (integers and floats).\n     */\n    void number();\n\n    /**\n     * @brief Check if the character is a separator.\n     * @param c Character to check.\n     * @return True if character is a separator, false otherwise.\n     */\n    bool isSeperator(char c) const;\n\n    /**\n     * @brief Check if the character is an operator.\n     * @param c Character to check.\n     * @return True if character is an operator, false otherwise.\n     */\n    bool isOperator(char c) const;\n\n    /**\n     * @brief Handle operators.\n     */\n    void handleOperator();\n\n    /**\n     * @brief Handle string literals.\n     */\n    void handleStringLiteral();\n\n    /**\n     * @brief Handle character literals.\n     */\n    void handleCharLiteral();\n\n    /**\n     * @brief Handle comments.\n     */\n    void handleComment();\n};\n\n#endif\n</code></pre></p>"},{"location":"compiler/internal/c_parser/","title":"3. Parser Documentation","text":""}]}